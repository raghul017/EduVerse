import { query } from "../config/database.js";
import { aiService } from "../services/ai.service.js";

export const listPaths = async (req, res, next) => {
  try {
    const rows = await query(
      `SELECT lp.id,
              lp.title,
              lp.description,
              lp.subject,
              lp.level,
              lp.created_at,
              u.name AS creator_name,
              COUNT(lpp.post_id)::int AS lessons_count
       FROM learning_paths lp
       LEFT JOIN learning_path_posts lpp ON lpp.path_id = lp.id
       LEFT JOIN users u ON u.id = lp.creator_id
       GROUP BY lp.id, u.name
       ORDER BY lp.created_at DESC`
    ).then((result) => result.rows);

    res.json({ data: rows });
  } catch (error) {
    next(error);
  }
};

export const aiRoadmap = async (req, res, next) => {
  try {
    const { role } = req.body;
    console.log(`[Path Controller] AI Roadmap request for role: ${role}`);
    console.log(`[Path Controller] Request body:`, JSON.stringify(req.body));
    console.log(`[Path Controller] User:`, req.user?.id || 'anonymous');
    
    if (!role || !role.trim()) {
      return res.status(400).json({ message: "Role is required." });
    }

    const roadmap = await aiService.generateRoadmap(role.trim());
    console.log(`[Path Controller] AI Roadmap result: ${roadmap ? 'success' : 'failed'}`);
    
    if (!roadmap || roadmap.error) {
      const errorMsg = roadmap?.error || "Unknown error";
      console.log(`[Path Controller] Returning fallback roadmap for: ${role}. Reason: ${errorMsg}`);
      const trimmed = role.trim();
      const fallback = {
        title: `${trimmed} Roadmap`,
        description:
          `AI provider is currently unavailable. Reason: ${errorMsg}. Please check your GROQ_API_KEY or GEMINI_API_KEY environment variables.`,
        stages: [
          {
            id: "basics",
            label: "Foundations",
            summary: "Core fundamentals for this role.",
            nodes: [
              {
                id: "overview",
                label: `${trimmed} Overview`,
                details:
                  "Understand what this role does day to day. Read 1–2 high-level guides.",
                dependsOn: [],
              },
              {
                id: "core-concepts",
                label: "Core Concepts",
                details:
                  "List the main technologies and concepts required. Prioritize 3–5 that you want to learn first.",
                dependsOn: ["overview"],
              },
            ],
          },
          {
            id: "projects",
            label: "Projects",
            summary: "Build small projects to apply the basics.",
            nodes: [
              {
                id: "mini-project",
                label: "Mini Project",
                details:
                  "Pick a simple project idea related to this role. Break it into 3–5 tasks and complete them.",
                dependsOn: ["core-concepts"],
              },
            ],
          },
        ],
      };
      return res.json({ data: fallback });
    }

    res.json({ data: roadmap });
  } catch (error) {
    console.error("[Path Controller] AI Roadmap error:", error);
    next(error);
  }
};

export const aiCourse = async (req, res, next) => {
  try {
    const { topic } = req.body;
    if (!topic || !topic.trim()) {
      return res.status(400).json({ message: "Topic is required." });
    }

    const course = await aiService.generateCourse(topic);
    if (!course) {
      const trimmed = topic.trim();
      // Rich Fallback for Demo/Offline Mode
      const fallback = {
        title: `Mastering ${trimmed}`,
        description: `A comprehensive guide to becoming an expert in ${trimmed}. Generated by EduVerse AI (Offline Mode).`,
        modules: [
          {
            id: "m1",
            title: "Fundamentals & Core Concepts",
            summary: "Build a solid foundation by understanding the key principles.",
            lessons: [
              {
                id: "l1",
                title: `Introduction to ${trimmed}`,
                objective: "Understand the history, importance, and basic terminology.",
                suggestedResources: [{ type: "video", title: `${trimmed} Crash Course`, url: "" }]
              },
              {
                id: "l2",
                title: "Environment Setup",
                objective: "Configure your development environment and tools.",
                suggestedResources: [{ type: "docs", title: "Official Documentation", url: "" }]
              },
              {
                id: "l3",
                title: "Key Syntax & Structure",
                objective: "Learn the essential syntax and structural patterns.",
                suggestedResources: []
              }
            ],
          },
          {
            id: "m2",
            title: "Advanced Techniques",
            summary: "Move beyond the basics into professional-grade skills.",
            lessons: [
              {
                id: "l4",
                title: "State Management & Data Flow",
                objective: "Master how data moves through your application.",
                suggestedResources: []
              },
              {
                id: "l5",
                title: "Performance Optimization",
                objective: "Techniques to make your solution faster and more efficient.",
                suggestedResources: []
              }
            ],
          },
          {
            id: "m3",
            title: "Real-world Project",
            summary: "Apply your knowledge by building a capstone project.",
            lessons: [
              {
                id: "l6",
                title: "Project Planning",
                objective: "Scope out a realistic project MVP.",
                suggestedResources: []
              },
              {
                id: "l7",
                title: "Implementation & Deployment",
                objective: "Build, test, and deploy your final project.",
                suggestedResources: []
              }
            ],
          }
        ],
      };
      return res.json({ data: fallback });
    }

    res.json({ data: course });
  } catch (error) {
    next(error);
  }
};

export const aiResources = async (req, res, next) => {
  try {
    const { topic, role } = req.body;
    if (!topic) {
      return res.status(400).json({ message: "Topic is required." });
    }

    const resources = await aiService.generateResources(topic, role || "General");
    res.json({ data: resources });
  } catch (error) {
    next(error);
  }
};

export const getPath = async (req, res, next) => {
  try {
    const id = req.params.id;
    const path = await query(
      `SELECT lp.id,
              lp.title,
              lp.description,
              lp.subject,
              lp.level,
              lp.created_at,
              u.name AS creator_name
       FROM learning_paths lp
       LEFT JOIN users u ON u.id = lp.creator_id
       WHERE lp.id = $1`,
      [id]
    ).then((result) => result.rows[0]);

    if (!path)
      return res.status(404).json({ message: "Learning path not found" });

    const lessons = await query(
      `SELECT p.*,
              lpp.position,
              lpp.resources
       FROM learning_path_posts lpp
       JOIN posts p ON p.id = lpp.post_id
       WHERE lpp.path_id = $1
       ORDER BY lpp.position ASC`,
      [id]
    ).then((result) => result.rows);

    res.json({ data: { ...path, lessons } });
  } catch (error) {
    next(error);
  }
};

export const createPath = async (req, res, next) => {
  try {
    const creatorId = req.user.id;
    const { title, description, subject, level, lessons } = req.body;
    if (!title || !Array.isArray(lessons) || lessons.length === 0) {
      return res
        .status(400)
        .json({ message: "Title and at least one lesson are required." });
    }

    await query("BEGIN");
    try {
      const createdPath = await query(
        `INSERT INTO learning_paths (creator_id, title, description, subject, level)
         VALUES ($1,$2,$3,$4,$5)
         RETURNING id, title, description, subject, level, created_at`,
        [creatorId, title, description || null, subject || null, level || null]
      ).then((result) => result.rows[0]);

      const isObjectShape =
        Array.isArray(lessons) &&
        lessons.length > 0 &&
        typeof lessons[0] === "object" &&
        lessons[0] !== null;

      const values = [];
      const placeholders = [];

      lessons.forEach((lesson, index) => {
        const lessonId = isObjectShape ? lesson.postId : lesson;
        if (!lessonId) return;
        const resources = isObjectShape ? lesson.resources || null : null;
        values.push(createdPath.id, lessonId, index + 1, resources);
        const base = values.length - 3; // path_id, post_id, position, resources
        placeholders.push(
          `($${base}, $${base + 1}, $${base + 2}, $${base + 3})`
        );
      });

      if (values.length) {
        await query(
          `INSERT INTO learning_path_posts (path_id, post_id, position, resources)
           VALUES ${placeholders.join(",")}`,
          values
        );
      }

      await query("COMMIT");
      res.status(201).json({ data: createdPath });
    } catch (error) {
      await query("ROLLBACK");
      throw error;
    }
  } catch (error) {
    next(error);
  }
};

export const getPathProgress = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const pathId = req.params.id;
    const progress = await query(
      `SELECT current_step, completed
       FROM user_path_progress
       WHERE user_id = $1 AND path_id = $2`,
      [userId, pathId]
    ).then((result) => result.rows[0]);

    res.json({ data: progress || { current_step: 0, completed: false } });
  } catch (error) {
    next(error);
  }
};

export const updatePathProgress = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const pathId = req.params.id;
    const { current_step, completed } = req.body;

    const updated = await query(
      `INSERT INTO user_path_progress (user_id, path_id, current_step, completed, updated_at)
       VALUES ($1,$2,$3,COALESCE($4,false), NOW())
       ON CONFLICT (user_id, path_id)
       DO UPDATE SET current_step = EXCLUDED.current_step,
                     completed = EXCLUDED.completed,
                     updated_at = NOW()
       RETURNING current_step, completed`,
      [userId, pathId, current_step || 0, completed]
    ).then((result) => result.rows[0]);

    res.json({ data: updated });
  } catch (error) {
    next(error);
  }
};
