import { query } from "../config/database.js";
import { aiService } from "../services/ai.service.js";
import { RoadmapModel, ProgressModel } from "../models/roadmap.model.js";

export const listPaths = async (req, res, next) => {
  try {
    const rows = await query(
      `SELECT lp.id,
              lp.title,
              lp.description,
              lp.subject,
              lp.level,
              lp.created_at,
              u.name AS creator_name,
              COUNT(lpp.post_id)::int AS lessons_count
       FROM learning_paths lp
       LEFT JOIN learning_path_posts lpp ON lpp.path_id = lp.id
       LEFT JOIN users u ON u.id = lp.creator_id
       GROUP BY lp.id, u.name
       ORDER BY lp.created_at DESC`
    ).then((result) => result.rows);

    res.json({ data: rows });
  } catch (error) {
    next(error);
  }
};

export const aiRoadmap = async (req, res, next) => {
  try {
    const { role, forceRegenerate } = req.body;
    const userId = req.user?.id;
    
    console.log(`[Path Controller] AI Roadmap request for role: ${role}`);
    console.log(`[Path Controller] User:`, userId || "anonymous");
    console.log(`[Path Controller] Force regenerate:`, forceRegenerate);

    if (!role || !role.trim()) {
      return res.status(400).json({ message: "Role is required." });
    }

    // Check for existing roadmap (unless forceRegenerate is true)
    if (userId && !forceRegenerate) {
      const existingRoadmap = await RoadmapModel.getRoadmap(userId, role.trim());
      if (existingRoadmap) {
        console.log(`âœ… [Path Controller] LOADING FROM CACHE for ${role} (user: ${userId})`);
        console.log(`[Path Controller] No AI call needed - returning cached roadmap`);
        return res.json({
          ...existingRoadmap.roadmap_data,
          fromCache: true,
          roadmapId: existingRoadmap.id
        });
      }
    }

    // Generate new roadmap
    console.log(`ðŸ¤– [Path Controller] GENERATING NEW ROADMAP with AI for ${role}`);
    console.log(`[Path Controller] Calling AI service...`);
    const roadmap = await aiService.generateRoadmap(role.trim());
    console.log(
      `[Path Controller] AI Roadmap result: ${roadmap ? "success" : "failed"}`
    );

    if (!roadmap || roadmap.error) {
      const errorMsg = roadmap?.error || "Unknown error";
      console.error(
        `[Path Controller] AI Roadmap generation failed: ${errorMsg}`
      );
      return res.status(503).json({ 
        message: "AI service is currently unavailable. Please try again.",
        error: errorMsg 
      });
    }

    // Save roadmap if user is authenticated
    if (userId) {
      const savedRoadmap = await RoadmapModel.saveRoadmap(userId, role.trim(), roadmap);
      roadmap.roadmapId = savedRoadmap.id;
    }

    return res.json(roadmap);
  } catch (error) {
    console.error("[Path Controller] Error in aiRoadmap:", error.message);
    console.error("[Path Controller] Stack:", error.stack);
    return res.status(500).json({ 
      message: "Failed to generate roadmap",
      error: error.message 
    });
  }
};

export const aiCourse = async (req, res, next) => {
  try {
    const { topic } = req.body;
    if (!topic || !topic.trim()) {
      return res.status(400).json({ message: "Topic is required." });
    }

    const course = await aiService.generateCourse(topic);
    if (!course) {
      const trimmed = topic.trim();
      // Rich Fallback for Demo/Offline Mode
      const fallback = {
        title: `Mastering ${trimmed}`,
        description: `A comprehensive guide to becoming an expert in ${trimmed}. Generated by EduVerse AI (Offline Mode).`,
        modules: [
          {
            id: "m1",
            title: "Fundamentals & Core Concepts",
            summary:
              "Build a solid foundation by understanding the key principles.",
            lessons: [
              {
                id: "l1",
                title: `Introduction to ${trimmed}`,
                objective:
                  "Understand the history, importance, and basic terminology.",
                suggestedResources: [
                  { type: "video", title: `${trimmed} Crash Course`, url: "" },
                ],
              },
              {
                id: "l2",
                title: "Environment Setup",
                objective: "Configure your development environment and tools.",
                suggestedResources: [
                  { type: "docs", title: "Official Documentation", url: "" },
                ],
              },
              {
                id: "l3",
                title: "Key Syntax & Structure",
                objective:
                  "Learn the essential syntax and structural patterns.",
                suggestedResources: [],
              },
            ],
          },
          {
            id: "m2",
            title: "Advanced Techniques",
            summary: "Move beyond the basics into professional-grade skills.",
            lessons: [
              {
                id: "l4",
                title: "State Management & Data Flow",
                objective: "Master how data moves through your application.",
                suggestedResources: [],
              },
              {
                id: "l5",
                title: "Performance Optimization",
                objective:
                  "Techniques to make your solution faster and more efficient.",
                suggestedResources: [],
              },
            ],
          },
          {
            id: "m3",
            title: "Real-world Project",
            summary: "Apply your knowledge by building a capstone project.",
            lessons: [
              {
                id: "l6",
                title: "Project Planning",
                objective: "Scope out a realistic project MVP.",
                suggestedResources: [],
              },
              {
                id: "l7",
                title: "Implementation & Deployment",
                objective: "Build, test, and deploy your final project.",
                suggestedResources: [],
              },
            ],
          },
        ],
      };
      return res.json({ data: fallback });
    }

    res.json({ data: course });
  } catch (error) {
    next(error);
  }
};

export const aiResources = async (req, res, next) => {
  try {
    const { topic, context } = req.body;
    console.log(`[Path Controller] AI Resources request for topic: ${topic}`);

    if (!topic) {
      return res.status(400).json({ message: "Topic is required." });
    }

    const resources = await aiService.generateResources(topic, context || "");
    console.log(`[Path Controller] Resources generated successfully`);

    res.json({
      resources: resources.freeResources || [],
      premiumResources: resources.premiumResources || [],
      description:
        resources.description || `Learn ${topic} to enhance your skills.`,
    });
  } catch (error) {
    console.error("[Path Controller] Chat error:", error);
    next(error);
  }
};

// Save or update progress for a roadmap node
export const saveProgress = async (req, res, next) => {
  try {
    const { roadmapId, nodeId, completed } = req.body;
    const userId = req.user.id;

    if (!roadmapId || !nodeId || completed === undefined) {
      return res.status(400).json({ 
        message: "roadmapId, nodeId, and completed are required" 
      });
    }

    const progress = await ProgressModel.saveProgress(
      userId,
      roadmapId,
      nodeId,
      completed
    );

    res.json({ data: progress });
  } catch (error) {
    console.error("[Path Controller] Save progress error:", error);
    next(error);
  }
};

// Get all progress for a roadmap
export const getProgress = async (req, res, next) => {
  try {
    const { roadmapId } = req.params;
    const userId = req.user.id;

    if (!roadmapId) {
      return res.status(400).json({ message: "roadmapId is required" });
    }

    const progress = await ProgressModel.getRoadmapProgress(userId, roadmapId);
    res.json({ data: progress });
  } catch (error) {
    console.error("[Path Controller] Get progress error:", error);
    next(error);
  }
};

// Get user's roadmaps
export const getUserRoadmaps = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const roadmaps = await RoadmapModel.getUserRoadmaps(userId);
    res.json({ data: roadmaps });
  } catch (error) {
    console.error("[Path Controller] Get user roadmaps error:", error);
    next(error);
  }
};

export const getPath = async (req, res, next) => {
  try {
    const id = req.params.id;
    const path = await query(
      `SELECT lp.id,
              lp.title,
              lp.description,
              lp.subject,
              lp.level,
              lp.created_at,
              u.name AS creator_name
       FROM learning_paths lp
       LEFT JOIN users u ON u.id = lp.creator_id
       WHERE lp.id = $1`,
      [id]
    ).then((result) => result.rows[0]);

    if (!path)
      return res.status(404).json({ message: "Learning path not found" });

    const lessons = await query(
      `SELECT p.*,
              lpp.position,
              lpp.resources
       FROM learning_path_posts lpp
       JOIN posts p ON p.id = lpp.post_id
       WHERE lpp.path_id = $1
       ORDER BY lpp.position ASC`,
      [id]
    ).then((result) => result.rows);

    res.json({ data: { ...path, lessons } });
  } catch (error) {
    next(error);
  }
};

export const createPath = async (req, res, next) => {
  try {
    const creatorId = req.user.id;
    const { title, description, subject, level, lessons } = req.body;
    if (!title || !Array.isArray(lessons) || lessons.length === 0) {
      return res
        .status(400)
        .json({ message: "Title and at least one lesson are required." });
    }

    await query("BEGIN");
    try {
      const createdPath = await query(
        `INSERT INTO learning_paths (creator_id, title, description, subject, level)
         VALUES ($1,$2,$3,$4,$5)
         RETURNING id, title, description, subject, level, created_at`,
        [creatorId, title, description || null, subject || null, level || null]
      ).then((result) => result.rows[0]);

      const isObjectShape =
        Array.isArray(lessons) &&
        lessons.length > 0 &&
        typeof lessons[0] === "object" &&
        lessons[0] !== null;

      const values = [];
      const placeholders = [];

      lessons.forEach((lesson, index) => {
        const lessonId = isObjectShape ? lesson.postId : lesson;
        if (!lessonId) return;
        const resources = isObjectShape ? lesson.resources || null : null;
        values.push(createdPath.id, lessonId, index + 1, resources);
        const base = values.length - 3; // path_id, post_id, position, resources
        placeholders.push(
          `($${base}, $${base + 1}, $${base + 2}, $${base + 3})`
        );
      });

      if (values.length) {
        await query(
          `INSERT INTO learning_path_posts (path_id, post_id, position, resources)
           VALUES ${placeholders.join(",")}`,
          values
        );
      }

      await query("COMMIT");
      res.status(201).json({ data: createdPath });
    } catch (error) {
      await query("ROLLBACK");
      throw error;
    }
  } catch (error) {
    next(error);
  }
};

export const getPathProgress = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const pathId = req.params.id;
    const progress = await query(
      `SELECT current_step, completed
       FROM user_path_progress
       WHERE user_id = $1 AND path_id = $2`,
      [userId, pathId]
    ).then((result) => result.rows[0]);

    res.json({ data: progress || { current_step: 0, completed: false } });
  } catch (error) {
    next(error);
  }
};

export const updatePathProgress = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const pathId = req.params.id;
    const { current_step, completed } = req.body;

    const updated = await query(
      `INSERT INTO user_path_progress (user_id, path_id, current_step, completed, updated_at)
       VALUES ($1,$2,$3,COALESCE($4,false), NOW())
       ON CONFLICT (user_id, path_id)
       DO UPDATE SET current_step = EXCLUDED.current_step,
                     completed = EXCLUDED.completed,
                     updated_at = NOW()
       RETURNING current_step, completed`,
      [userId, pathId, current_step || 0, completed]
    ).then((result) => result.rows[0]);

    res.json({ data: updated });
  } catch (error) {
    next(error);
  }
};

export const getAiUsage = async (req, res, next) => {
  try {
    const stats = aiService.getUsageStats();
    res.json({ data: stats });
  } catch (error) {
    next(error);
  }
};

export const aiChat = async (req, res, next) => {
  try {
    const { message, context } = req.body;
    
    if (!message) {
      return res.status(400).json({ message: "Message is required." });
    }

    const result = await aiService.chatWithTutor(message, context);
    
    if (result.error) {
      return res.status(503).json({ message: result.error });
    }

    res.json(result);
  } catch (error) {
    next(error);
  }
};
